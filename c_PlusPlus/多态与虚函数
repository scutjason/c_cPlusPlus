1、多态，一般理解用父类的指针去调用子类中被重写的方法。有一种面向接口的说法，就是一个接口，多种实现

2、多态的重点还是实现虚函数，即在父类中定义一个virtual虚函数，子类中去重写这个虚函数，这样用父类的指针去调用子类的这个重写方法时，能够
直接调用子类的实现，在重写了虚函数时，会建立一个虚函数表vtable（里面保存着各个虚函数的地址），根据当前对象的不同，转而调用其实现的虚函数。
这种联系叫做动态绑定。

看一个简单的例子

#include <iostream>
#include "learn_cplus_plus.h"
using namespace std;

class A{
public:
    void foo()
    {
        cout << "foo a" << endl;
    }
    virtual void func()
    {
        cout << "func a" << endl;
    }
};

class B: public  A{  // B是a的子类
public:
    void foo()
    {
        cout << "foo b" << endl;
    }
     void func()
    {
        cout << "func b" << endl;
    }
};


int main() {
    A a;
    B b;
    a.foo();
    a.func();
    b.foo();
    b.func();

    A *p = &b;  // 基类指针可以直接指向子类对象
    p->foo();  // 跟着指针走
    p->func(); // 跟着对象走

    B *pb = (B*)&a; // 子类指针要加强转，才能执行基类
    pb->foo(); // 非虚函数直接就是子类，跟着指针走
    pb->func(); // 调用的这个虚函数，其实是基类对象a的，跟着对象走
    return 0;
}

>> 打印输出
foo a
func a
foo b
func b
foo a
func b
foo b
func a

3、通过指针或引用才是动态绑定，通过点运算是不可以的。
内联函数、静态函数、构造函数都不能是虚函数，析构函数通常是虚函数

4、多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，
就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。

5、纯虚函数： 因为有些基类没有对象，所以不适合有对象。比如动物这个类，本身就没有对象。
包含纯虚函数的类叫做抽象类，抽象类不能生成对象，只能被继承。
virtual void funtion()=0 
// 后面有个=0
